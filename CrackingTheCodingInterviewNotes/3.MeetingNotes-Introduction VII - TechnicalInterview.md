<h1>Technical Interview</h1>
<hr>
<h2>Memorizing solutions won't help you much.</h2>
<ol>
    <li>Try solving the problem on your own</li>
    <li>Write the code on paper</li>
    <li>Test your code on paper</li>
    <li>Type your paper code as is into a computer</li>
</ol>

<h2>Must have knowledge</h2>

| Data Structures      | Algorithms    | Concepts            |
| -------------------- | ------------- | ------------------- |
| Linked List          | Breadth First | Bit Manipulation    |
| Trees, Tries, Graphs | Depth First   | Memory              |
| Stack & Queues       | Binary Search | Recursion           |
| Heap                 | Merge Sort    | Dynamic Programming |
| Vector / Array Lists | Quick Sort    | Big O Time & Space  |

<h2>Power of 2 Table</h2>

<h2>Walking through a problem</h2>
<ol>
    <li>Listen Carefully</li>
    <li>Draw an Example
        <ul>
            <li>Be specific by using real numbers or strings</li>
            <li>Be careful to not create a special case</li>
        </ul>
    </li>
    <li>State a Brute Force
        <ul>
            <li>Despite being possibly slow, a brute force algorithm is valuable to discuss</li>            
        </ul>
    </li>
    <li>Optimize
        <ul>
            <li>Use a fresh example</li>            
        </ul>
    </li>
    <li>Walk Through
        <ul>
            <li>If writing pseudocode then be careful about what you write</li>            
        </ul>
    </li>
    <li>Implement
        <ul>
            <li>Code on whiteboard</li>
            <li>Write beautiful code
                <ul>
                    <li>Modularize Code</li>
                    <li>Error checks</li>
                    <li>Use other classes/structs when appropriate</li>
                    <li>Good variable names</li>
                </ul>
            </li>
        </ul>
    </li>
    <li>Test
        <ol>
            <li>Start with a conceptual test</li>
            <li>Weird looking Code</li>
            <li>Hot Spots</li>
            <li>Small test cases</li>
            <li>Special Cases</li>
        </ol>
    </li>
</ol>

<br>
<br>
<h2>Optimize & Solve Techniques</h2>
<h3>#1 Look for B.U.D</h3>
<ul>
    <li>Bottlenecks</li>
    <li>Unnecessary Work</li>
    <li>Duplicated Work</li>
</ul>

<h3>#2 Do It Yourself</h3>
<p>Remove the idea of code an try and solve the problem manually. Example going througha stack of papers where names are sorted in alphabetical order. How would you find "Tucker"?</p>

<h3>#3 Simplify & Generalize</h3>
<p>Start with a simple example and then generalize it.</p>

<h3>#4 Base Case & Build</h3>
<ul>
    <li>
        Start with a small test case theny try to build up the test cases by using the same algorithm. Example: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10. If you can't solve the problem for 1 then you can't solve it for 10.
    </li>
    <li>
        Base Case and Build algorithms often lead to natural recursion.
    </li>
</ul>

<h3>#5 Data Structure Brainstorm</h3>
<ul>
    <li>Think about the data structures that you know and how they can be used to solve the problem.</li>
    <li>Think about the pros and cons of each data structure.</li>
    <li>Think about how you can combine data structures to solve the problem.</li>
</ul>

<br>
<br>
<h2>Handling Incorrect Answers</h2>
<ul>
    <li>A candidant does not have to get every question right.</li>
    <li>Performance is compared to other candidates.</li>
    <li>Some times questionsare meant to be hard to test how someone reacts to a difficult problem.</li>
</ul>

<br>
<br>

<h2>The "Perfect" language for interviews</h2>
<p> Just go with what you comfortable with just as long as it's readable.</p>

<h2>What good coding looks like</h2>
<ul>
    <li>Correct: operate on the correct inputs and produce the correct outputs.</li>
    <li>Efficient</li>
    <li>Simple: easy to read and understand.</li>
    <li>Readable: good variable names, good spacing, good comments.</li>
    <li>Maintainable: easy to change and reuse.</li>
</ul>

<h2>Use data structures generously</h2>
<h2>Modularize Code</h2>
<h2>Flexible and Robust Code</h2>
<h2>Error Checking</h2>
